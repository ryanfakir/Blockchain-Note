首先 zk-SNARKs  和 zk-STARKs 是两个很大的块 一次肯定讲不完 而且 这个很多数学paper 需要看  看的很慢 。先来说说SNARKs zk-STARKs 区别再与一个是non interactive（交互）  一个是 interactive。 这两个主要用在目前流行的加密货币中 什么意思？ 假设有两个个体A， B 其中 A 不希望B 知道所有A的内部信息的情况下 可以通过构建SNARKS 向B 证明 B 可以相信A。 上例子， 假如有个色盲朋友 分辨不清楚 红绿 色盲并不知道你的内部信息 即红绿球各一个  请问 怎么想色盲证明你手里有红绿两种球，而不是都是红 都是绿呢？ 这里就用到了信息不对称下的概率的deterministic。你把两个球都给色盲 并指出红绿两个球各是哪个 然后随便让色盲把球放到身后 shuffle(打乱顺序) 这里色盲是知道他shuffle的顺序 ， 色盲每次可以出一个球让你判断颜色， 假如你可以以百分之百的概率 在不知道shuffle结果的情况下 回答出颜色， 随着这种判断次数越多 是不就可以approve 你没有骗 色盲。 结论：zk（zero knowledge）指 信息不对称的情况下 approver 在保证隐私的情况可以 向 verifier（验证者） 概率上验证verifier statement 的正确性。 上面多轮的approve 就是STARKs , 而一次性的验证 则是SNARKs。因为SNARKs是一次性的 所以需要有个setup（设置）的阶段。 这就是如何产生statement的概念。 SNARKs需要多方生成POLYNOMIALS（多项式） 这就是第一次的模型转换 即把系统参数 比如交易信息 hash算法 做加权 生成POLYNOMIALS的过程 而之前的两方approver （A）和 verifier （V）是通过POLYNOMIALs的结果进行判定的。 因为在两个POLYNOMIALS在algebra（线性代数） 中可以证明唯一性 即P（x） 如果P一样的话 在概率上两个P（x）的结果也应该是一致的。同时为了让P的信息（系统信息）不泄露给V， V 只允许有限长的statement 比如string（字符串）asdf231031ddfafdoij....  有限的statement 保证的是 V 不会知道 P 是什么 这里保证了A隐私 在给定长的string中 V 给A几个加密的（challenge ）质疑， 这里加密函数假设是E E需要满足 E（X + Y） = E（X） + E（Y） 加密函数则是为了保证A不去猜出challenge 然后伪造P， 因为 制造lower degree（低系数） 的 POLYNOMIALS是相对容易满足结果的。 所以整个验证过程如下：V发送E(1),E(s),…,E(s power of d). A 本地验算E(P(s)) 然后发送结果回去 假如V E(1),E(s),…,E(s power of d) 跟 E(P(s)) 则成功否则失败。 之后有机会把更深入的研究一下 完了分享 
链接：链接：https://z.cash/blog/snark-explain.html
链接：https://www.youtube.com/watch?v=oubB-VoFnQk&list=PLs7piyBKGCl86icksb-Lj9M4hcl4oRKNO&index=3&t=695s
链接：https://www.youtube.com/watch?v=KSZB9hsrh3c
链接：https://www.youtube.com/watch?v=HJ9K_o-RRSY
链接：https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell/
链接：https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649
