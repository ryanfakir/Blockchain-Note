  抽了点时间用大白话写出来： 首先什么是UTXO 为什么他是无状态的（stateless）， 我们要了解传统的银行的账户（account）模型， 你的银行账户有100块是因为系统中数据库你的账户XXX = 100块。 你的账户是有状态的因为你能不能花101 取决于你之前的账户够不够100.  而UTXO 是什么 首先他也是记录账户信息的方式， 但是它不需要记录你之前的账户状态 而是谁发给谁， 比如典型的UTXO 模型是 A 发给B 100 块， 但这种怎么保证A 有一百块呢？ 好问题！ UTXO 简化讲是input 和 ouput。 input是以可以花的钱， 如果input大于output就可以花， 而input需要验证是否为真 也即到底有没有A 给B 打钱。 同样的A 也需要验证 C到底有没有给A 打钱 下一个问题 UTXO 的好处和坏处 ： 普通模型需要存下所有流水交易记录 来验证 这样子在数据库需要两份存储 上面的例子 A to B A 要存 发走多少钱 B 要存受到多少钱 UTXO 则不需要 但是UTXO 的坏处 是需要大量验证 追根到底 才能验证 这样加重 的计算难度 另外UTXO 为什么 是并发 什么叫并发就是多件事情一起做 因为在UTXO 只需要知道多个input 比 多个output多就好 没有顺序问题 但是传统模型中 A 花了90 块 在花20块就不可以了 这叫事件互斥 传统模型需要有顺序， 因为存在事件互斥 而UTXO 却不需要。 所以这就是为什么UTXO 是stateless 而account base smart contract 是stateful 量子链为什么做敢做UTXO 因为account model在 Serenity之后已经把 protocol 下降到EVM （以太虚拟机）中， 这样子量子做UTXO 模型也完全会兼容EVM 我猜想量子没有做虚拟机方面的人才把 所以才想搭EVM的顺风车 UTXO 实现起来非常复杂 而且没有必要 以太房是目前基于account的传统的模型 所有smart contract 也就是代码 都需要维护状态 比特币目前是UTXO 导致很多第三方钱包需要没发解决大量验证input的问题 强制用了account sequential 模型 因为UTXO 的验证input 本身是计算机里的图（graph）问题 这个可能NP 问题 也就是不可解问题 这就是QTUM 说的 带来了松耦合 和一定的并发性 大家要注意是带来 而不是实现 因为实现起来是非常困难的 是学术级讨论问题 有兴趣同学给你贴一片论文看看 链接：http://fc16.ifca.ai/bitcoin/papers/MES16.pdf

